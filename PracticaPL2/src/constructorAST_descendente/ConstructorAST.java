/* Generated By:JavaCC: Do not edit this line. ConstructorAST.java */
package constructorAST_descendente;

import analizadorSintactico.AnalizadorSintacticoTiny1.*;
import semops.SemOps;

@SuppressWarnings({"unused", "unchecked", "rawtypes"})
public class ConstructorAST implements ConstructorASTConstants {
   private SemOps sem = new SemOps();

final public Programa Sp() throws ParseException {
                   Programa programa;
    programa = Programa();
    jj_consume_token(0);
                                                                 {if (true) return programa;}
    throw new Error("Missing return statement in function");
  }

  final public Programa Programa() throws ParseException {
                         LDecs ldecs; LIns lins;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case proc:
    case var:
    case type:
    case sep:
      ldecs = LDecs();
      jj_consume_token(sep);
      lins = LIns();
                                                                                       {if (true) return sem.programa_con_decs(ldecs, lins);}
      break;
    case numeroEntero:
    case numeroReal:
    case cadena:
    case not:
    case null_pr:
    case true_pr:
    case false_pr:
    case if_pr:
    case while_pr:
    case call:
    case new_pr:
    case delete:
    case read:
    case write:
    case nl:
    case resta:
    case multiplicacion:
    case pApert:
    case llaveAper:
    case identificador:
      lins = LIns();
                                                                 {if (true) return sem.programa_sin_decs(lins);}
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public LDecs LDecs() throws ParseException {
                   Dec dec; LDecs rldecs;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case proc:
    case var:
    case type:
      dec = Dec();
      rldecs = RLDecs(sem.decs_1(dec));
                                                                  {if (true) return rldecs;}
      break;
    default:
      jj_la1[1] = jj_gen;
                     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public LDecs RLDecs(LDecs ldecs_h) throws ParseException {
                                 Dec dec; LDecs rldecs;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case pyc:
      jj_consume_token(pyc);
      dec = Dec();
      rldecs = RLDecs(sem.decs_muchas(ldecs_h, dec));
                                                                                                    {if (true) return rldecs;}
      break;
    default:
      jj_la1[2] = jj_gen;
                                   {if (true) return ldecs_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Dec Dec() throws ParseException {
               Tipo tipo; Token id; LParams parform; Bloque bloque;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case var:
      jj_consume_token(var);
      tipo = Tipo();
      id = jj_consume_token(identificador);
                                                          {if (true) return sem.dec_var(tipo, sem.str(id.image, id.beginLine, id.beginColumn));}
      break;
    case type:
      jj_consume_token(type);
      tipo = Tipo();
      id = jj_consume_token(identificador);
                                                           {if (true) return sem.dec_type(tipo, sem.str(id.image, id.beginLine, id.beginColumn));}
      break;
    case proc:
      jj_consume_token(proc);
      id = jj_consume_token(identificador);
      parform = ParForm();
      bloque = Bloque();
                                                                                   {if (true) return sem.dec_proc(sem.str(id.image, id.beginLine, id.beginColumn), parform, bloque);}
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public LParams ParForm() throws ParseException {
                       LParams lparams;
    jj_consume_token(pApert);
    lparams = LParams();
    jj_consume_token(pCierre);
                                                                {if (true) return lparams;}
    throw new Error("Missing return statement in function");
  }

  final public LParams LParams() throws ParseException {
                       Param param; LParams rlparams;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case int_pr:
    case real:
    case bool:
    case string:
    case record:
    case array:
    case pointer:
    case identificador:
      param = Param();
      rlparams = RLParams(sem.lparams_1(param));
                                                                                   {if (true) return rlparams;}
      break;
    default:
      jj_la1[4] = jj_gen;
                         {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public LParams RLParams(LParams lparams_h) throws ParseException {
                                         Param param; LParams rlparams;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case coma:
      jj_consume_token(coma);
      param = Param();
      rlparams = RLParams(sem.lparams_muchos(lparams_h, param));
                                                                                                                            {if (true) return rlparams;}
      break;
    default:
      jj_la1[5] = jj_gen;
                                           {if (true) return lparams_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Param Param() throws ParseException {
                   Tipo tipo; Referencia ref; Token id;
    tipo = Tipo();
    ref = Referencia();
    id = jj_consume_token(identificador);
                                                                           {if (true) return sem.param(tipo, ref, sem.str(id.image, id.beginLine, id.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Referencia Referencia() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ampersand:
      jj_consume_token(ampersand);
                                           {if (true) return sem.referencia();}
      break;
    default:
      jj_la1[6] = jj_gen;
                               {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Bloque Bloque() throws ParseException {
                     Programa programa;
    jj_consume_token(llaveAper);
    programa = ProgramaBloque();
    jj_consume_token(llaveCierre);
                                                                          {if (true) return sem.bloque(programa);}
    throw new Error("Missing return statement in function");
  }

  final public Programa ProgramaBloque() throws ParseException {
                               Programa programa;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case numeroEntero:
    case numeroReal:
    case cadena:
    case not:
    case null_pr:
    case true_pr:
    case false_pr:
    case proc:
    case if_pr:
    case while_pr:
    case call:
    case new_pr:
    case delete:
    case read:
    case write:
    case nl:
    case var:
    case type:
    case resta:
    case multiplicacion:
    case sep:
    case pApert:
    case llaveAper:
    case identificador:
      programa = Programa();
                                                                   {if (true) return programa;}
      break;
    default:
      jj_la1[7] = jj_gen;
                                 {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Tipo Tipo() throws ParseException {
                 Token t; Tipo tipo; LCampos lcampos;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case int_pr:
      jj_consume_token(int_pr);
                            {if (true) return sem.tipo_int();}
      break;
    case real:
      jj_consume_token(real);
                          {if (true) return sem.tipo_real();}
      break;
    case bool:
      jj_consume_token(bool);
                          {if (true) return sem.tipo_bool();}
      break;
    case string:
      jj_consume_token(string);
                            {if (true) return sem.tipo_string();}
      break;
    case identificador:
      t = jj_consume_token(identificador);
                                       {if (true) return sem.tipo_id(sem.str(t.image, t.beginLine, t.beginColumn));}
      break;
    case array:
      jj_consume_token(array);
      jj_consume_token(corApert);
      t = jj_consume_token(numeroEntero);
      jj_consume_token(corCierre);
      jj_consume_token(of);
      tipo = Tipo();
                                                                                        {if (true) return sem.tipo_array(sem.str(t.image, t.beginLine, t.beginColumn), tipo);}
      break;
    case record:
      jj_consume_token(record);
      jj_consume_token(llaveAper);
      lcampos = LCampos();
      jj_consume_token(llaveCierre);
                                                                          {if (true) return sem.tipo_record(lcampos);}
      break;
    case pointer:
      jj_consume_token(pointer);
      tipo = Tipo();
                                           {if (true) return sem.tipo_pointer(tipo);}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public LCampos LCampos() throws ParseException {
                       Campo campo; LCampos rlcampos;
    campo = Campo();
    rlcampos = RLCampos(sem.lcampos_1(campo));
                                                                                  {if (true) return rlcampos;}
    throw new Error("Missing return statement in function");
  }

  final public LCampos RLCampos(LCampos lcampos_h) throws ParseException {
                                         Campo campo; LCampos rlcampos;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case pyc:
      jj_consume_token(pyc);
      campo = Campo();
      rlcampos = RLCampos(sem.lcampos_muchos(lcampos_h, campo));
                                                                                                                           {if (true) return rlcampos;}
      break;
    default:
      jj_la1[9] = jj_gen;
                                           {if (true) return lcampos_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Campo Campo() throws ParseException {
                   Tipo tipo; Token id;
    tipo = Tipo();
    id = jj_consume_token(identificador);
                                                       {if (true) return sem.campo(tipo, sem.str(id.image, id.beginLine, id.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public LIns LIns() throws ParseException {
                 Ins ins; LIns rlins;
    ins = Ins();
    rlins = RLIns(sem.lins_1(ins));
                                                             {if (true) return rlins;}
    throw new Error("Missing return statement in function");
  }

  final public LIns RLIns(LIns lins_h) throws ParseException {
                             Ins ins; LIns rlins;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case pyc:
      jj_consume_token(pyc);
      ins = Ins();
      rlins = RLIns(sem.lins_muchas(lins_h, ins));
                                                                                            {if (true) return rlins;}
      break;
    default:
      jj_la1[10] = jj_gen;
                               {if (true) return lins_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Ins Ins() throws ParseException {
               Exp exp1, exp2; LInsV linsv; Token id; LParamsReales lparamsreales; Bloque bloque; Ins rinsifthen;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case numeroEntero:
    case numeroReal:
    case cadena:
    case not:
    case null_pr:
    case true_pr:
    case false_pr:
    case resta:
    case multiplicacion:
    case pApert:
    case identificador:
      exp1 = E0();
      jj_consume_token(igual);
      exp2 = E0();
                                                  {if (true) return sem.ins_asignacion(exp1, exp2);}
      break;
    case while_pr:
      jj_consume_token(while_pr);
      exp1 = E0();
      jj_consume_token(do_pr);
      linsv = LInsV();
      jj_consume_token(endwhile);
                                                                             {if (true) return sem.ins_while(exp1, linsv);}
      break;
    case read:
      jj_consume_token(read);
      exp1 = E0();
                                     {if (true) return sem.ins_read(exp1);}
      break;
    case write:
      jj_consume_token(write);
      exp1 = E0();
                                      {if (true) return sem.ins_write(exp1);}
      break;
    case nl:
      jj_consume_token(nl);
                       {if (true) return sem.ins_nl();}
      break;
    case new_pr:
      jj_consume_token(new_pr);
      exp1 = E0();
                                       {if (true) return sem.ins_new(exp1);}
      break;
    case delete:
      jj_consume_token(delete);
      exp1 = E0();
                                       {if (true) return sem.ins_delete(exp1);}
      break;
    case call:
      jj_consume_token(call);
      id = jj_consume_token(identificador);
      jj_consume_token(pApert);
      lparamsreales = LParamsReales();
      jj_consume_token(pCierre);
                                                                                                 {if (true) return sem.ins_call(sem.str(id.image, id.beginLine, id.beginColumn), lparamsreales);}
      break;
    case llaveAper:
      bloque = Bloque();
                                    {if (true) return sem.ins_bloque(bloque);}
      break;
    case if_pr:
      jj_consume_token(if_pr);
      exp1 = E0();
      jj_consume_token(then);
      linsv = LInsV();
      rinsifthen = RInsIfThen(exp1, linsv);
                                                                                                  {if (true) return rinsifthen;}
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Ins RInsIfThen(Exp exp1_h, LInsV linsv_h) throws ParseException {
                                               LInsV linsv;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case endif:
      jj_consume_token(endif);
                                                         {if (true) return sem.ins_if(exp1_h, linsv_h);}
      break;
    case else_pr:
      jj_consume_token(else_pr);
      linsv = LInsV();
      jj_consume_token(endif);
                                                                                   {if (true) return sem.ins_if_else(exp1_h, linsv_h, linsv);}
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public LInsV LInsV() throws ParseException {
                   Ins ins; LInsV rlinsv;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case numeroEntero:
    case numeroReal:
    case cadena:
    case not:
    case null_pr:
    case true_pr:
    case false_pr:
    case if_pr:
    case while_pr:
    case call:
    case new_pr:
    case delete:
    case read:
    case write:
    case nl:
    case resta:
    case multiplicacion:
    case pApert:
    case llaveAper:
    case identificador:
      ins = Ins();
      rlinsv = RLInsV(sem.linsv_1(ins));
                                                                   {if (true) return rlinsv;}
      break;
    default:
      jj_la1[13] = jj_gen;
                     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public LInsV RLInsV(LInsV linsv_h) throws ParseException {
                                 Ins ins; LInsV rlinsv;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case pyc:
      jj_consume_token(pyc);
      ins = Ins();
      rlinsv = RLInsV(sem.linsv_muchas(linsv_h, ins));
                                                                                                     {if (true) return rlinsv;}
      break;
    default:
      jj_la1[14] = jj_gen;
                                   {if (true) return linsv_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public LParamsReales LParamsReales() throws ParseException {
                                   Exp exp1; LParamsReales lparamsreales;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case numeroEntero:
    case numeroReal:
    case cadena:
    case not:
    case null_pr:
    case true_pr:
    case false_pr:
    case resta:
    case multiplicacion:
    case pApert:
    case identificador:
      exp1 = E0();
      lparamsreales = RLParamsReales(sem.preales_1(exp1));
                                                                                                     {if (true) return lparamsreales;}
      break;
    default:
      jj_la1[15] = jj_gen;
                                     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public LParamsReales RLParamsReales(LParamsReales lparamsreales_h) throws ParseException {
                                                                 Exp exp1; LParamsReales rlparamsreales;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case coma:
      jj_consume_token(coma);
      exp1 = E0();
      rlparamsreales = RLParamsReales(sem.preales_muc(lparamsreales_h, exp1));
                                                                                                                                                              {if (true) return rlparamsreales;}
      break;
    default:
      jj_la1[16] = jj_gen;
                                                                   {if (true) return lparamsreales_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E0() throws ParseException {
              Exp exp1, re0;
    exp1 = E1();
    re0 = RE0(exp1);
                                           {if (true) return re0;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RE0(Exp exp_h) throws ParseException {
                        Exp exp1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case suma:
      jj_consume_token(suma);
      exp1 = E0();
                                             {if (true) return sem.suma(exp_h, exp1);}
      break;
    case resta:
      jj_consume_token(resta);
      exp1 = E1();
                                              {if (true) return sem.resta(exp_h, exp1);}
      break;
    default:
      jj_la1[17] = jj_gen;
                          {if (true) return exp_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E1() throws ParseException {
              Exp exp1; Exp re1;
    exp1 = E2();
    re1 = RE1(exp1);
                                           {if (true) return re1;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RE1(Exp exp_h) throws ParseException {
                        Exp exp1; Exp re1; String op;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case and:
    case or:
      op = OpN1();
      exp1 = E2();
      re1 = RE1(sem.exp(op, exp_h, exp1));
                                                                                    {if (true) return re1;}
      break;
    default:
      jj_la1[18] = jj_gen;
                        {if (true) return exp_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E2() throws ParseException {
              Exp exp1, re2;
    exp1 = E3();
    re2 = RE2(exp1);
                                          {if (true) return re2;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RE2(Exp exp_h) throws ParseException {
                        String op; Exp exp1, re2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case menor:
    case mayor:
    case menorIgual:
    case mayorIgual:
    case igualdad:
    case distinto:
      op = OpN2();
      exp1 = E3();
      re2 = RE2(sem.exp(op, exp_h, exp1));
                                                                                   {if (true) return re2;}
      break;
    default:
      jj_la1[19] = jj_gen;
                        {if (true) return exp_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E3() throws ParseException {
              Exp exp1, re3;
    exp1 = E4();
    re3 = RE3(exp1);
                                          {if (true) return re3;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RE3(Exp exp_h) throws ParseException {
                        String op; Exp exp1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case multiplicacion:
    case division:
    case modulo:
      op = OpN3();
      exp1 = E4();
                                                {if (true) return sem.exp(op, exp_h, exp1);}
      break;
    default:
      jj_la1[20] = jj_gen;
                        {if (true) return exp_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E4() throws ParseException {
              Exp exp1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case resta:
      jj_consume_token(resta);
      exp1 = E5();
                                    {if (true) return sem.menos(exp1);}
      break;
    case not:
      jj_consume_token(not);
      exp1 = E4();
                                  {if (true) return sem.not(exp1);}
      break;
    case numeroEntero:
    case numeroReal:
    case cadena:
    case null_pr:
    case true_pr:
    case false_pr:
    case multiplicacion:
    case pApert:
    case identificador:
      exp1 = E5();
                            {if (true) return exp1;}
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E5() throws ParseException {
              Exp exp1, re5;
    exp1 = E6();
    re5 = RRE5(exp1);
                                            {if (true) return re5;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RRE5(Exp exp_h) throws ParseException {
                         Exp re5, rre5;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case corApert:
    case punto:
    case flecha:
      re5 = RE5(exp_h);
      rre5 = RRE5(re5);
                                                           {if (true) return rre5;}
      break;
    default:
      jj_la1[22] = jj_gen;
                           {if (true) return exp_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp RE5(Exp exp_h) throws ParseException {
                        Exp exp1; Token id;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case corApert:
      jj_consume_token(corApert);
      exp1 = E0();
      jj_consume_token(corCierre);
                                                           {if (true) return sem.index(exp_h, exp1);}
      break;
    case punto:
      jj_consume_token(punto);
      id = jj_consume_token(identificador);
                                                     {if (true) return sem.access_reg_punto(exp_h, sem.str(id.image, id.beginLine, id.beginColumn));}
      break;
    case flecha:
      jj_consume_token(flecha);
      id = jj_consume_token(identificador);
                                                      {if (true) return sem.access_reg_flecha(exp_h, sem.str(id.image, id.beginLine, id.beginColumn));}
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E6() throws ParseException {
              Exp exp1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case multiplicacion:
      jj_consume_token(multiplicacion);
      exp1 = E6();
                                             {if (true) return sem.indireccion(exp1);}
      break;
    case numeroEntero:
    case numeroReal:
    case cadena:
    case null_pr:
    case true_pr:
    case false_pr:
    case pApert:
    case identificador:
      exp1 = E7();
                            {if (true) return exp1;}
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E7() throws ParseException {
              Token id; Exp exp1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case identificador:
      id = jj_consume_token(identificador);
                                      {if (true) return sem.identificador(sem.str(id.image, id.beginLine, id.beginColumn));}
      break;
    case numeroEntero:
      id = jj_consume_token(numeroEntero);
                                     {if (true) return sem.numEnt(sem.str(id.image, id.beginLine, id.beginColumn));}
      break;
    case numeroReal:
      id = jj_consume_token(numeroReal);
                                   {if (true) return sem.numReal(sem.str(id.image, id.beginLine, id.beginColumn));}
      break;
    case true_pr:
      jj_consume_token(true_pr);
                           {if (true) return sem.true_p();}
      break;
    case false_pr:
      jj_consume_token(false_pr);
                            {if (true) return sem.false_p();}
      break;
    case cadena:
      id = jj_consume_token(cadena);
                               {if (true) return sem.cadena(sem.str(id.image, id.beginLine, id.beginColumn));}
      break;
    case null_pr:
      jj_consume_token(null_pr);
                           {if (true) return sem.null_p();}
      break;
    case pApert:
      jj_consume_token(pApert);
      exp1 = E0();
      jj_consume_token(pCierre);
                                                {if (true) return exp1;}
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String OpN1() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case and:
      jj_consume_token(and);
                         {if (true) return "and";}
      break;
    case or:
      jj_consume_token(or);
                        {if (true) return "or";}
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String OpN2() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case menor:
      jj_consume_token(menor);
                           {if (true) return "<";}
      break;
    case mayor:
      jj_consume_token(mayor);
                           {if (true) return ">";}
      break;
    case menorIgual:
      jj_consume_token(menorIgual);
                                {if (true) return "<=";}
      break;
    case mayorIgual:
      jj_consume_token(mayorIgual);
                                {if (true) return ">=";}
      break;
    case igualdad:
      jj_consume_token(igualdad);
                              {if (true) return "==";}
      break;
    case distinto:
      jj_consume_token(distinto);
                              {if (true) return "!=";}
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String OpN3() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case multiplicacion:
      jj_consume_token(multiplicacion);
                                    {if (true) return "*";}
      break;
    case division:
      jj_consume_token(division);
                              {if (true) return "/";}
      break;
    case modulo:
      jj_consume_token(modulo);
                            {if (true) return "%";}
      break;
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public ConstructorASTTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[29];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x48fc0c80,0x400000,0x0,0x400000,0x8000f000,0x0,0x0,0x48fc0c80,0x8000f000,0x0,0x0,0x48bc0c80,0x6000000,0x48bc0c80,0x0,0x3c0c80,0x0,0x0,0x30000,0x0,0x0,0x3c0c80,0x0,0x0,0x380c80,0x380c80,0x30000,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x10405bf8,0x300,0x1000000,0x300,0x5,0x0,0x0,0x10405bf8,0x5,0x1000000,0x1000000,0x104018f8,0x0,0x104018f8,0x1000000,0x401800,0x0,0xc00,0x0,0x3f0000,0xb000,0x401800,0xc4000000,0xc4000000,0x401000,0x400000,0x0,0x3f0000,0xb000,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x4,0x0,0x0,0x0,0x4,0x1,0x2,0x4,0x4,0x0,0x0,0x4,0x0,0x4,0x0,0x4,0x1,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x4,0x4,0x0,0x0,0x0,};
   }

  public ConstructorAST(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ConstructorASTTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  public ConstructorAST(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ConstructorASTTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  public ConstructorAST(ConstructorASTTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  public void ReInit(ConstructorASTTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;


public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[67];
    for (int i = 0; i < 67; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 29; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 67; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
