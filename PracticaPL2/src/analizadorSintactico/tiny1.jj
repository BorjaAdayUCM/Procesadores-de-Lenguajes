options  {
  STATIC=false;
}  
PARSER_BEGIN(AnalizadorSintacticoTiny)
package analizadorSintactico;

public class AnalizadorSintacticoTiny {}
PARSER_END(AnalizadorSintacticoTiny)

  SKIP:{<["\t"," ","\r","\b","\n"]>}
  SKIP:{<"#"(~["\n"])*>} 
  TOKEN:{<#letra:["a"-"z","A"-"Z"]>}
  TOKEN:{<#digitoPositivo:["1"-"9"]>}
  TOKEN:{<#digito:<digitoPositivo>|"0">} 
  TOKEN:{<#parteEntera:<digitoPositivo>(<digito>)* |"0">} 
  TOKEN:{<numeroEntero:("+"|"-")?<parteEntera>>}
  TOKEN:{<#parteDecimal:"."("0"|(<digito>)*<digitoPositivo>)>}
  TOKEN:{<#parteExponencial:("E"|"e")<numeroEntero>>}
  TOKEN:{<numeroReal:<numeroEntero>(<parteDecimal>|<parteExponencial>|<parteDecimal><parteExponencial>)>}
  TOKEN:{<cadena:"\""(~["\"","\t","\b","\r","\n"])*"\"">}
  TOKEN: {<int_pr:"int">}
  TOKEN: {<real:"real">}
  TOKEN: {<bool:"bool">}
  TOKEN: {<string:"string">}
  TOKEN: {<and:"and">}
  TOKEN: {<or:"or">}
  TOKEN: {<not:"not">}
  TOKEN: {<null_pr:"null">}
  TOKEN: {<true_pr:"true">}
  TOKEN: {<false_pr:"false">}
  TOKEN: {<proc:"proc">}
  TOKEN: {<if_pr:"if">}
  TOKEN: {<then:"then">}
  TOKEN: {<else_pr:"else">}
  TOKEN: {<endif:"endif">}
  TOKEN: {<while_pr:"while">}
  TOKEN: {<do_pr:"do">}
  TOKEN: {<endwhile:"endwhile">}
  TOKEN: {<call:"call">}
  TOKEN: {<record:"record">}
  TOKEN: {<array:"array">}
  TOKEN: {<of:"of">}
  TOKEN: {<pointer:"pointer">}
  TOKEN: {<new_pr:"new">}
  TOKEN: {<delete:"delete">}
  TOKEN: {<read:"read">}
  TOKEN: {<write:"write">}
  TOKEN: {<nl:"nl">}
  TOKEN: {<var:"var">}
  TOKEN: {<type:"type">}
  TOKEN: {<suma:"+">}
  TOKEN: {<resta:"-">}
  TOKEN: {<multiplicacion:"*">}
  TOKEN: {<division:"/">}
  TOKEN: {<sep:"&&">}
  TOKEN: {<modulo:"%">}
  TOKEN: {<menor:"<">}
  TOKEN: {<mayor:">">}
  TOKEN: {<menorIgual:"<=">}
  TOKEN: {<mayorIgual:">=">}
  TOKEN: {<igualdad:"==">}
  TOKEN: {<distinto:"!=">}
  TOKEN: {<pApert:"(">}
  TOKEN: {<pCierre:")">}
  TOKEN: {<pyc:";">}
  TOKEN: {<igual:"=">}
  TOKEN: {<corApert:"[">}
  TOKEN: {<corCierre:"]">}
  TOKEN: {<llaveAper:"{">}
  TOKEN: {<llaveCierre:"}">}
  TOKEN: {<punto:".">}
  TOKEN: {<flecha:"->">}
  TOKEN: {<coma:",">}
  TOKEN: {<ampersand:"&">}
  TOKEN:{<identificador:<letra>(<letra>|<digito>|"_")*>}
  

  void Programa() : {} {PDeclaraciones() PInstrucciones() <EOF>}
  void PDeclaraciones() : {} {LDecs() <sep> | {}}

  void LDecs() : {} {Dec() RLDecs()}
  void RLDecs() : {} {<pyc> Dec() RLDecs() | {}}

  void Dec() : {} {<var> Tipo() <identificador> | <type> Tipo() <identificador> | <proc> <identificador> ParForm() Bloque()}
  void ParForm() : {} {<pApert> LParams() <pCierre>}

  void LParams() : {} {Param() RLParams() | {}}
  void RLParams() : {} {<coma> Param() RLParams() | {}}

  void Param() : {} {Tipo() Referencia() <identificador>}
  void Referencia() : {} {<ampersand> | {}}
  void Bloque() : {} {<llaveAper> RBloque()}
  void RBloque() : {} {Programa() <llaveCierre> | <llaveCierre>}
  void Tipo() : {} {<int_pr> | <real> | <bool> | <string> | <identificador> | <array> <corApert> <numeroEntero> <corCierre> <of> Tipo() | <record> <llaveAper> LCampos() <llaveCierre> | <pointer> Tipo()}

  void LCampos() : {} {Campo() RLCampos()}
  void RLCampos() : {} {<pyc> Campo() RLCampos() | {}}

  void Campo() : {} {Tipo() <identificador>}

  void PInstrucciones() : {} {LIns()}

  void LIns() : {} {Ins() RLIns()}
  void RLIns() : {} {<pyc> Ins() RLIns() | {}}

  void Ins() : {} {E0() <igual> E0() | InsIfThen() RInsIfThen() | <while_pr> E0() <do_pr> LInsV() <endwhile> | <read> E0() | <write> E0() | <nl> | <new_pr> E0() | <delete> E0() | <call> <identificador> <pApert> LParamsReales() <pCierre> | Bloque()}

  void InsIfThen() : {} {<if_pr> E0() <then> LInsV()}
  void RInsIfThen() : {} {<endif> | <else_pr> LInsV() <endif>}

  void LInsV() : {} {Ins() RLInsV() | {}}
  void RLInsV() : {} {<pyc> Ins() RLInsV() | {}}

  void LParamsReales() : {} {E0() RLParamsReales() | {}}
  void RLParamsReales() : {} {<coma> E0() RLParamsReales() | {}}

  void E0() : {} {E1() RE0()}
  void RE0() : {} {<suma> E0() | <resta> E1() | {}}

  void E1() : {} {E2() RE1()}
  void RE1() : {} {OpN1() E2() RE1() | {}}

  void E2() : {} {E3() RE2()}
  void RE2() : {} {OpN2() E3() RE2() | {}}

  void E3() : {} {E4() RE3()}
  void RE3() : {} {OpN3() E4() | {}}

  void E4() : {} {<resta> E5() | <not> E4() | E5()}

  void E5() : {} {E6() RE5()}
  void RE5() : {} {OpN5() RE5() | {}}

  void E6() : {} {<multiplicacion> E6() | E7()}

  void E7() : {} {<identificador> | <numeroEntero> | <numeroReal> | <true_pr> | <false_pr> | <cadena> | <null_pr> | <pApert> E0() <pCierre>}

  void OpN1() : {} {<and> | <or>}
  void OpN2() : {} {<menor> | <mayor> | <menorIgual> | <mayorIgual> | <igualdad> | <distinto>}
  void OpN3() : {} {<multiplicacion> | <division> | <modulo>}
  void OpN5() : {} {<corApert> E0() <corCierre> | <punto> <identificador> | <flecha> <identificador>}